import * as AuthSession from 'expo-auth-session';
import * as WebBrowser from 'expo-web-browser';

// Complete the auth session on web browsers
WebBrowser.maybeCompleteAuthSession();

export class YotoAuth {
  static CLIENT_ID = 'NJ4lW4Y3FrBcpR4R6YlkKs30gTxPjvC4';
  static REDIRECT_URI = 'https://gandhiv88.github.io/yoto-callback/';
  static YOTO_AUTH_ENDPOINT = 'https://login.yotoplay.com/authorize';
  static YOTO_TOKEN_ENDPOINT = 'https://login.yotoplay.com/oauth/token';
  
  // Prevent multiple auth sessions running simultaneously 
  static isAuthInProgress = false;

  // Test with different redirect URIs to fix "Type Locked" error
  static ALTERNATIVE_REDIRECT_URIS = [
    'https://gandhiv88.github.io/yoto-callback/',
    'exp://192.168.1.93:8081', // Local development
    'http://localhost:3000/callback', // Local callback
  ];

  static async authenticate() {
    try {
      console.log('🚀 [AUTH] Starting OAuth authentication flow...');
      
      // Prevent multiple auth sessions
      if (this.isAuthInProgress) {
        console.log('⚠️ [AUTH] Authentication already in progress, please wait...');
        return {
          success: false,
          error: 'Authentication already in progress. Please wait for the current session to complete.'
        };
      }
      
      this.isAuthInProgress = true;
      debugger; // This will pause execution in Chrome DevTools
      
      // Try authentication with the primary redirect URI first
      const result = await this.tryAuthenticationWithRedirectURI(this.REDIRECT_URI);
      
      if (result.success) {
        return result;
      } else if (result.error && result.error.includes('locked')) {
        console.log('🔄 [AUTH] Primary redirect failed with "locked" error, trying alternatives...');
        
        // Try alternative redirect URIs
        for (const redirectUri of this.ALTERNATIVE_REDIRECT_URIS.slice(1)) {
          console.log(`🔄 [AUTH] Trying redirect URI: ${redirectUri}`);
          const altResult = await this.tryAuthenticationWithRedirectURI(redirectUri);
          if (altResult.success) {
            return altResult;
          }
        }
      }
      
      return result; // Return the last result if all attempts failed
    } catch (error) {
      console.error('🚨 [AUTH] Authentication error:', error);
      console.error('🚨 [AUTH] Error stack:', error.stack);
      debugger; // Pause on error
      return {
        success: false,
        error: error.message || 'Authentication error'
      };
    } finally {
      // Always reset the flag when authentication is complete
      this.isAuthInProgress = false;
    }
  }

  static async tryAuthenticationWithRedirectURI(redirectUri) {
    try {
      console.log(`🚀 [AUTH] Trying authentication with redirect URI: ${redirectUri}`);
      
      // Configure OAuth request using Yoto's specific parameters
      const request = new AuthSession.AuthRequest({
        clientId: this.CLIENT_ID,
        scopes: ['offline_access'],
        redirectUri: redirectUri,
        responseType: AuthSession.ResponseType.Code,
        extraParams: {
          audience: 'https://api.yotoplay.com',
        },
        additionalParameters: {},
        prompt: AuthSession.Prompt.SelectAccount,
      });

      console.log('🔧 [AUTH] OAuth request configured:', {
        clientId: this.CLIENT_ID,
        redirectUri: redirectUri,
        scopes: ['offline_access'],
        audience: 'https://api.yotoplay.com'
      });

      debugger; // Pause before making the request

      // Discover auth endpoints
      const discovery = {
        authorizationEndpoint: this.YOTO_AUTH_ENDPOINT,
        tokenEndpoint: this.YOTO_TOKEN_ENDPOINT,
      };

      // Make auth request
      const result = await request.promptAsync(discovery);
      console.log('📥 [AUTH] Auth result:', result);
      debugger; // Pause to inspect auth result

      if (result.type === 'success') {
        console.log('✅ [AUTH] Auth successful, exchanging code for token...');
        debugger; // Pause before token exchange
        // Exchange code for token
        const tokenResult = await this.exchangeCodeForToken(result.params.code, redirectUri);
        
        if (tokenResult.success) {
          console.log('Authentication successful');
          return {
            success: true,
            token: tokenResult.access_token,
            refreshToken: tokenResult.refresh_token
          };
        } else {
          console.error('Token exchange failed:', tokenResult.error);
          return {
            success: false,
            error: tokenResult.error || 'Token exchange failed'
          };
        }
      } else if (result.type === 'cancel') {
        console.log('Authentication cancelled by user');
        return {
          success: false,
          error: 'Authentication cancelled'
        };
      } else {
        console.error('🚨 [AUTH] Authentication failed with result:', result);
        console.error('🚨 [AUTH] Result type:', result.type);
        console.error('🚨 [AUTH] Error details:', result.error);
        console.error('🚨 [AUTH] Full result object:', JSON.stringify(result, null, 2));
        debugger; // Pause to inspect the failed result
        
        let errorMessage = 'Authentication failed';
        if (result.type === 'locked') {
          errorMessage = 'Authentication is locked. Please try again later or check your account status.';
        } else if (result.error) {
          errorMessage = result.error.message || result.error.description || result.error;
        }
        
        return {
          success: false,
          error: errorMessage
        };
      }
    } catch (error) {
      console.error('🚨 [AUTH] Authentication error:', error);
      console.error('🚨 [AUTH] Error stack:', error.stack);
      debugger; // Pause on error
      return {
        success: false,
        error: error.message || 'Authentication error'
      };
    }
  }

  static async exchangeCodeForToken(code, redirectUri = this.REDIRECT_URI) {
    try {
      console.log('💱 [TOKEN] Exchanging authorization code for access token...');
      console.log('💱 [TOKEN] Code received:', code ? 'YES' : 'NO');
      debugger; // Pause at token exchange start
      
      const response = await fetch(this.YOTO_TOKEN_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json',
        },
        body: new URLSearchParams({
          grant_type: 'authorization_code',
          client_id: this.CLIENT_ID,
          code: code,
          redirect_uri: redirectUri,
          audience: 'https://api.yotoplay.com',
        }).toString(),
      });

      const data = await response.json();
      console.log('📊 [TOKEN] Token exchange response:', {
        status: response.status,
        hasAccessToken: !!data.access_token,
        hasRefreshToken: !!data.refresh_token,
        error: data.error,
        errorDescription: data.error_description
      });
      debugger; // Pause to inspect token response

      if (response.ok && data.access_token) {
        return {
          success: true,
          access_token: data.access_token,
          refresh_token: data.refresh_token,
          expires_in: data.expires_in,
          token_type: data.token_type
        };
      } else {
        return {
          success: false,
          error: data.error || data.error_description || 'Token exchange failed'
        };
      }
    } catch (error) {
      console.error('🚨 [TOKEN] Token exchange error:', error);
      console.error('🚨 [TOKEN] Error stack:', error.stack);
      debugger; // Pause on token error
      return {
        success: false,
        error: error.message || 'Token exchange error'
      };
    }
  }

  static async refreshToken(refreshToken) {
    try {
      console.log('Refreshing access token...');
      
      const response = await fetch(this.YOTO_TOKEN_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json',
        },
        body: new URLSearchParams({
          grant_type: 'refresh_token',
          client_id: this.CLIENT_ID,
          refresh_token: refreshToken,
        }).toString(),
      });

      const data = await response.json();
      console.log('Token refresh response:', {
        status: response.status,
        hasAccessToken: !!data.access_token
      });

      if (response.ok && data.access_token) {
        return {
          success: true,
          access_token: data.access_token,
          refresh_token: data.refresh_token || refreshToken,
          expires_in: data.expires_in,
          token_type: data.token_type
        };
      } else {
        return {
          success: false,
          error: data.error || data.error_description || 'Token refresh failed'
        };
      }
    } catch (error) {
      console.error('Token refresh error:', error);
      return {
        success: false,
        error: error.message || 'Token refresh error'
      };
    }
  }

  // Mock authentication for testing (remove when real OAuth is configured)
  static async mockAuthenticate() {
    return new Promise((resolve) => {
      setTimeout(() => {
        // Return a mock token for testing
        const mockToken = 'mock-jwt-token-for-testing-' + Date.now();
        console.log('Mock authentication successful');
        resolve({
          success: true,
          token: mockToken
        });
      }, 1000);
    });
  }

  // Check if we have valid credentials
  static async isAuthenticated(token) {
    if (!token) return false;
    
    try {
      // Make a test API call to verify token validity
      const response = await fetch('https://api.yotoplay.com/v1/me', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/json',
        },
      });

      return response.ok;
    } catch (error) {
      console.error('Token validation error:', error);
      return false;
    }
  }

  // Test authentication flow for debugging
  static async testAuth() {
    try {
      console.log('Testing authentication flow...');
      console.log('Redirect URI:', this.REDIRECT_URI);
      console.log('Client ID:', this.CLIENT_ID);
      console.log('Auth endpoint:', this.YOTO_AUTH_ENDPOINT);
      
      const result = await this.authenticate();
      console.log('Test auth result:', result);
      return result;
    } catch (error) {
      console.error('Test auth error:', error);
      return { success: false, error: error.message };
    }
  }
}
